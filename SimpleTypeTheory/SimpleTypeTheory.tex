\documentclass[a4paper]{article}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage[utf8]{inputenc}
\usepackage{tikz-cd}
\usepackage[all, 2cell]{xy}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage[all]{xy}
\usepackage{tikz}
\usetikzlibrary{graphs}
\usetikzlibrary{arrows}
\usepackage{hyperref}
\usepackage[english,russian]{babel}
\begin{document}
\title{Лямбда-исчисление.}
\section{Немного истории.}
\section{Введение в лямбда-исчисление: определения и базовые результаты.}

Рассмотрим мотивирующий пример. Когда мы пишем, что <<функция отображает аргумент $x$ в $M$>>, где $M$ --- это метапеременная,
в которой лежит тело функции, то мы используем следующую нотацию $x \mapsto M$, тогда как запись $\lambda x.M$ следует читать точно
также в содержательном смысле. Расширим наш мотивирующий и не совсем формальный пример,
заменив метапеременную $M$ на более понятное арифметическое выражение : $x \mapsto x^2 + 6x + 9$ и $\lambda x.x^2 + 6x + 9$.

Теперь же перейдем к формальным определениям. Базовое понятие в $\lambda$-исчислении --- это \emph{предтерм}. Предположим, у нас есть бесконечный алфавит:

\begin{equation}
\Lambda = {v_0, v_1, v_2, v_3, ... }
\end{equation}

\emph{Предтермами} мы будем называть конечные строки над алфавитом $\Lambda$, порожденные следующей грамматикой:

\begin{equation}
\Lambda_{term} ::= \Lambda \: | \: (\Lambda_{term} \Lambda_{term}) \: | \: \lambda \Lambda . \Lambda_{term}
\end{equation}

Примеры конечных строк, порожденных заданной грамматикой:

1) $((v_3 \: v_5) \: v_8)$;

2) $\lambda v_6. v_5 v_6$

3) $\lambda v_0. v_0$

4) $\lambda v_{05091995}.\lambda v_{38}.v_{4}$


Как мы видим из определения грамматики, предтермы бывают трех видов.

Зададим классификацию предтермов в соответсвии с грамматикой:

1) Предтерм первого вида (это просто элементы $\Lambda$) называется \emph{переменной}, которые мы будем обозначать тремя предпоследними буквами
латинского алфавита $x, y, z, ...$ (возможно с индексами);

2) Предтерм второго вида (записанные два подряд предтерма) называется \emph{аппликацией} (или \emph{применением}), которую мы будем обозначать $(M N)$, где
$M$ и $N$ --- это произвольные предтермы, которые впредь будут обозначаться метапеременными $M, N, O,...$ (возможно с индексами);

3) Предтерм третьего вида (знак $\lambda$ с переменной, точка и предтерм) называется $\lambda$-\emph{абстракцией}, которая будет обозначаться как $\lambda x.M$,
где $x$ является \emph{связанной переменной}. Если в предтерме встречается переменная $x$, которая связана $\lambda$-оператором,
то такая переменная будет называться \emph{свободной переменной}.

В свою очередь, свободные переменные определяются так:

Пусть $M$ --- предтерм. Определим его множество свободных переменных $FV(M) \subseteq V$ следующим образом:

a) $FV(x) = {x}$;

b) $FV(M N) = FV(M) \cup FV(N)$;

c) $FV(\lambda x. M) = FV(M)$.

Рассмотрим примеры:

1) $FV(\lambda x. xx) = \emptyset$;

2) $FV(\lambda x. g(f x)) = \{g, f\}$;

3) $FV((\lambda x. y(yx))(\lambda x.y) = FV(\lambda x. y(yx)) \cup FV(\lambda x.y) = \{ y \} \cup \{ y\} = \{ y\}$;

4) $FV(\lambda x. ffffff(x)) = \{ f \}$;

5) $FV(\lambda x. \lambda y. y) = \emptyset$.

Поясним, что $\lambda$ --- это оператор связывания. Пусть у нас есть некоторый предтерм $M$, содержащий свободные вхождения $x$. Теперь мы $\lambda$-абстрагируемся
по $x$ и получим предтерм третьего вида $\lambda x. M$, предъявляя таким образом выражение, зависящее от значения параметра $x$.

\textbf{Важное терминологическое соглашение}: любой предтерм, удовлетворяющий тому или иному виду, мы будет называть $\lambda$-термами.

$\lambda$-исчисление же начинается тогда, когда мы вводим систему правил преобразования термов:

1) $\alpha$-конверсия --- правило переименования связанных переменных: $\lambda x.M \rightarrow_{\beta} \lambda y.M[x := y]$.
Важно следить, чтобы переименование не вызывало коллизий, например: $\lambda x. xy \rightarrow_{\beta} \lambda y.yy[x := y]$. Видно,
что до переименования в нашем терме была одна связанная переменная, которая в теле функции применяется к свободному параметру $y$.
Далее, мы заменили связанную переменную на $y$ и получили на выходе терм, который внешне отличен от исходного, поскольку после переименования
наша связанная переменная в терме в теле функции уже применяется сама к себе.

Над $\lambda$-термами мы можем ввести отношение $\alpha$-эквивалентности (что пишется как $M \equiv_{\alpha} N$), которое, как и любое другое отношение эквивалентности,
рефлексивно, симметрично и транзитивно:

i) $M \equiv_{\alpha} M$

ii) $M \equiv_{\alpha} N \Rightarrow N \equiv_{\alpha} M$

iii) $M \equiv_{\alpha} N, N \equiv_{\alpha} P \Rightarrow M \equiv_{\alpha} P$

Действительно, во-первых, любой лямбда-терм тривиально эквивалентен сам себе при
тождественном переименовании связанных переменных, никак не меняющем исходные имена. Во-вторых, если мы переименовали связанные переменные,
то мы вполне имеем право сделать обратное переименование, восстанавливающее исходный терм, что и дает нам симметричное свойство
отношения $\alpha$-эквивалентности. И, в-третьих, если мы переименовали связанные переменные, а затем переименовали связанные
переменные в результате первого переименования, то мы вправе рассматривать такую цепочку переименований как переименование связанных переменных в
исходном терме на имена, что связанные переменные имеют в конце данной цепочки. Таким образом, транзитивность у нас также проходит.

Поскольку, $\alpha$-эквивалентность --- это отношение эквивалентности, то мы имеем право разбить $\lambda$-термы на классы эквивалентностей следующего вида:

\begin{equation}
[M]_{\alpha} = \{ N \in \Lambda_{term} \: | \: M \equiv_{\alpha} N \}
\end{equation}

Таким образом, фактор-множество по данному отношению, будет состоять из указанных выше классов эквивалентностей, и данное фактор-множество как
раз и будет совокупностью $\lambda$-термов, то есть мы рассматриваем здесь и далее мы рассматриваем $\lambda$-термы с точностью до $\alpha$-эквивалентности.

2) $\beta$-редукция представляет собой некоторое обобщение правила вычисления. Формально правило выглядит так:

\begin{equation}
(\lambda x. M) N \rightarrow_{\beta} M[x := N]
\end{equation}

Мы берем лямбда-терм и применяем к нему терм $N$, а результатом данного применения является терм $M$, в котором все вхождения $x$ заменяются на $N$.
Терм вида $(\lambda x. M) N$ мы называем $\beta$-\emph{редексом}, а терм, не содержащий редексов, мы называет \emph{главной формой}.
Вернемся к нашему неформальному примеру $\lambda x.x^2 + 6x + 9$. Применим данный терм к $2$, то есть $(\lambda x.x^2 + 6x + 9) 2$, далее мы проведем подстановку и вычислим значение
при данной подстановке:
\begin{equation}
(\lambda x.x^2 + 6x + 9) 2 \rightarrow_{\beta} 2^2 + 6 \cdot 2 + 9 \rightarrow_{\beta} 25
\end{equation}
Таким образом, при заданной подстановке, $25$ является главной формой данного терма.

\emph{Примеры} $\beta$-редукции:

i) $(\lambda x. x x)N \rightarrow_{\beta} x x [x := N] \equiv N N$;

ii) $(\lambda x. (\lambda x. x x) f x)N \rightarrow_{\beta} ((\lambda x. x x) f x) [x := N] \equiv ((\lambda x. xx) f N)$;

iii) $(\lambda x.x) N \rightarrow_{\beta} (x) [x := N] \equiv N$;

iv) $(\lambda f. (\lambda g. (\lambda x. f (g x)))) \: M \: N \: P \rightarrow_{\beta} (\lambda g. (\lambda x. f (g x)) \: N \: P \:\: [f := M] \rightarrow_{\beta} (\lambda x. M (g x)) \: P \:\: [g := N] \rightarrow_{\beta} M (N x) [x := P] \equiv M (N P)$;

v) $(\lambda f. (\lambda g. (\lambda x . (f x) (g x)))) \: M \: N \: P \rightarrow_{\beta} (\lambda g. (\lambda x. (f x) (g x))) \: N \: P \:\: [f := M] \rightarrow_{\beta} (\lambda x. (M x) (g x)) \: P \:\: [g := N] \rightarrow_{\beta} (M x) (N x) [x := P] \equiv (M P) (N P)$;

vi) $(\lambda x. (\lambda y. x)) \: M \: N \rightarrow_{\beta} (\lambda y. x) \: N [x := M] \rightarrow_{\beta} M [y := N] \equiv M$;

vii) $(\lambda f. (\lambda x. f(f x))) \: M \: N \rightarrow_{\beta} (\lambda x. f(f x)) \: N [f := M] \rightarrow_{\beta} M (M x) [x := N] \equiv M (M N)$.



\section{Комбинаторная логика и ее связь с лямбда-исчислением.}
\section{Простое типизированное лямбда-исчисление: типизация по Карри и по Черчу.}
\section{Типизированные комбинаторы.}
\section{Практическая реализация лямбда-исчисления, комбинаторной логики и теории типов.}
\end{document}
