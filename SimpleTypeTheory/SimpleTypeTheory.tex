\documentclass[a4paper]{article}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage[utf8]{inputenc}
\usepackage{tikz-cd}
\usepackage[all, 2cell]{xy}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage[all]{xy}
\usepackage{tikz}
\usetikzlibrary{graphs}
\usetikzlibrary{arrows}
\usepackage{hyperref}
\usepackage[english,russian]{babel}
\begin{document}
\title{Лямбда-исчисление.}
\section{Немного истории.}
\section{Введение в лямбда-исчисление: определения и базовые результаты.}

Рассмотрим мотивирующий пример. Когда мы пишем, что <<функция отображает аргумент $x$ в $M$>>, где $M$ --- это метапеременная,
в которой лежит тело функции, то мы используем следующую нотацию $x \mapsto M$, тогда как запись $\lambda x.M$ следует читать точно
также в содержательном смысле. Расширим наш мотивирующий и не совсем формальный пример,
заменив метапеременную $M$ на более понятное арифметическое выражение : $x \mapsto x^2 + 6x + 9$ и $\lambda x.x^2 + 6x + 9$.

Теперь же перейдем к формальным определениям. Базовое понятие в $\lambda$-исчислении --- это \emph{предтерм}. Предположим, у нас есть бесконечный алфавит:

\begin{equation}
\Lambda = {v_0, v_1, v_2, v_3, ... }
\end{equation}

\emph{Предтермами} мы будем называть конечные строки над алфавитом $\Lambda$, порожденные следующей грамматикой:

\begin{equation}
\Lambda_{term} ::= \Lambda \: | \: (\Lambda_{term} \Lambda_{term}) \: | \: \lambda \Lambda . \Lambda_{term}
\end{equation}

Примеры конечных строк, порожденных заданной грамматикой:

1) $((v_3 \: v_5) \: v_8)$;

2) $\lambda v_6. v_5 v_6$

3) $\lambda v_0. v_0$

4) $\lambda v_{05091995}.\lambda v_{38}.v_{4}$


Как мы видим из определения грамматики, предтермы бывают трех видов.

Зададим классификацию предтермов в соответсвии с грамматикой:

1) Предтерм первого вида (это просто элементы $\Lambda$) называется \emph{переменной}, которые мы будем обозначать тремя предпоследними буквами
латинского алфавита $x, y, z, ...$ (возможно с индексами);

2) Предтерм второго вида (записанные два подряд предтерма) называется \emph{аппликацией} (или \emph{применением}), которую мы будем обозначать $(M N)$, где
$M$ и $N$ --- это произвольные предтермы, которые впредь будут обозначаться метапеременными $M, N, O,...$ (возможно с индексами);

3) Предтерм третьего вида (знак $\lambda$ с переменной, точка и предтерм) называется $\lambda$-\emph{абстракцией}, которая будет обозначаться как $\lambda x.M$,
где $x$ является \emph{связанной переменной}. Если в предтерме встречается переменная $x$, которая связана $\lambda$-оператором,
то такая переменная будет называться \emph{свободной переменной}.

Поясним, что $\lambda$ --- это оператор связывания. Пусть у нас есть некоторый предтерм $M$, содержащий свободные вхождения $x$. Теперь мы $\lambda$-абстрагируемся
по $x$ и получим предтерм третьего вида $\lambda x. M$, предъявляя таким образом выражение, зависящее от значения параметра $x$.

\textbf{Важное терминологическое соглашение}: любой предтерм, удовлетворяющий тому или иному виду, мы будет называть $\lambda$-термами.

$\lambda$-исчисление же начинается тогда, когда мы вводим систему правил преобразования термов:

1) $\alpha$-конверсия --- правило переименования связанных переменных: $\lambda x.M \rightarrow_{\beta} \lambda y.M[x := y]$.
Важно следить, чтобы переименование не вызывало коллизий, например: $\lambda x. xy \rightarrow_{\beta} \lambda y.yy[x := y]$. Видно,
что до переименования в нашем терме была одна связанная переменная, которая в теле функции применяется к свободному параметру $y$.
Далее, мы заменили связанную переменную на $y$ и получили на выходе терм, который внешне отличен от исходного, поскольку после переименования
наша связанная переменная в терме в теле функции уже применяется сама к себе.

Над $\lambda$-термами мы можем ввести отношение $\alpha$-эквивалентности (что пишется как $M \equiv_{\alpha} N$), которое, как и любое другое отношение эквивалентности,
рефлексивно, симметрично и транзитивно:

i) $M \equiv_{\alpha} M$

ii) $M \equiv_{\alpha} N \Rightarrow N \equiv_{\alpha} M$

iii) $M \equiv_{\alpha} N, N \equiv_{\alpha} P \Rightarrow M \equiv_{\alpha} P$

Действительно, во-первых, любой лямбда-терм тривиально эквивалентен сам себе при
тождественном переименовании связанных переменных, никак не меняющем исходные имена. Во-вторых, если мы переименовали связанные переменные,
то мы вполне имеем право сделать обратное переименование, восстанавливающее исходный терм, что и дает нам симметричное свойство
отношения $\alpha$-эквивалентности. И, в-третьих, если мы переименовали связанные переменные, а затем переименовали связанные
переменные в результате первого переименования, то мы вправе рассматривать такую цепочку переименований как переименование связанных переменных в
исходном терме на имена, что связанные переменные имеют в конце данной цепочки. Таким образом, транзитивность у нас также проходит.

Поскольку, $\alpha$-эквивалентность --- это отношение эквивалентности, то мы имеем право разбить $\lambda$-термы на классы эквивалентностей следующего вида:

\begin{equation}
[M]_{\alpha} = {N \in \Lambda_{term} \: | \: M \equiv_{\alpha} N}
\end{equation}

Таким образом, фактор-множество по данному отношению, будет состоять из указанных выше классов эквивалентностей, и данное фактор-множество как
раз и будет совокупностью $\lambda$-термов, то есть мы рассматриваем здесь и далее мы рассматриваем $\lambda$-термы с точностью до $\alpha$-эквивалентности.

2) $\beta$-редукция представляет собой некоторое обобщение правила вычисления. Формально правило выглядит так:

\begin{equation}
(\lambda x. M) N \rightarrow_{\beta} M[x := N]
\end{equation}

Мы берем лямбда-терм и применяем к нему терм $N$, а результатом данного применения является терм $M$, в котором все вхождения $x$ заменяются на $N$.


\section{Комбинаторная логика и ее связь с лямбда-исчислением.}
\section{Простое типизированное лямбда-исчисление: типизация по Карри и по Черчу.}
\section{Типизированные комбинаторы.}
\section{Практическая реализация лямбда-исчисления, комбинаторной логики и теории типов.}
\end{document}
